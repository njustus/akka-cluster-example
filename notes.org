
* Protokoll zeigen: TextEditingProtocol
- Bsp in Scala
- join, leave
- TextFileUpdate: update von Coordinator an EditingPeers
- EditLine: Peer sendet Textänderung
* Model zeigen: TextFile
- EditPatch: 1 Zeile samt Bearbeiter/Peer
- TextFile: Dokument

* LocalMain zeigen
Aktoren:
- TextFile starten
- tim, bob, ina starten

* TextFileActor zeigen
- 1x ohne Implementierung starten -> dead letters für Join
- join implementieren
  #+begin_src scala
  case TextEditingProtocol.Join =>
      log.info("{} joins", sender().path.name)
      editingPeers += sender()
      sender() ! TextEditingProtocol.TextFileUpdate(currentTextFile, self)
  #+end_src
- Peers bekommen initiale Datei, versuchen zu ändern.
- Patch implementieren
  #+begin_src scala
  case editLine:TextEditingProtocol.EditLine =>
      log.info("received edit {} from {}", editLine, sender())
      val patch = EditPatch(editLine.content, Some(sender().path.name))

      val newTextFile = interpreter.editLine(currentTextFile, editLine.lineNo, patch)
  #+end_src
- ausführen, testen
  *Achtung:* Peers kriegen kein update

- Patch um update Peers erweitern
  #+begin_src scala
    private def updateTextFile(newTextFile: TextFile, source: ActorRef): Unit = {
    currentTextFile = newTextFile

    val textFileUpdate = TextEditingProtocol.TextFileUpdate(newTextFile, source)
    log.debug("editing patch applied, notify peers")
    editingPeers.foreach { actor =>
      actor.tell(textFileUpdate, context.self)
    }
  }
  #+end_src

* ClusteredMain zeigen
- =registerOnMemberUp= = sobald das Cluster bereit ist
- ausimplementieren
#+begin_src scala

    val actorPath = s"akka://editing-system@${getServerAddress(system.settings)}/user/$coordinatorName"
    val pathFuture = system.actorSelection(actorPath).resolveOne(5 minutes)

    val textFileActor = Await.result(pathFuture, 5 minutes)
    log.info("remote path: " + textFileActor.path)

    val tim = system.actorOf(EditingPeerActor.props(textFileActor), "Tim")
    val ina = system.actorOf(EditingPeerActor.props(textFileActor), "Ina")
#+end_src

- =actorPath= Pfad/Adresse erstellen und auflösen
- peers starten mit aufgelöster Adresse
- Adresse kann auch aus *Zookeeper* gelesen werden
- Adresse könnte auch ein Event im Cluster sein
- Rest *identisch*

* UI zeigen

* Abschluss
- Fragen?

- das waren die Basics. Gerade an der Oberfläche gekratzt.
- Wollt ihr mehr sehen? streaming, http?

** Fragen
- gleichzeitiges ändern 1 Zeile führt zum gegenseitigen überschreiben. In Google Docs genauso.
  *keine* Änderung geht verloren.

** Einsatzbereiche
- Interaktive Anwendungen (mit WebSockets)
- Real Time Anwendungen
- Event Driven Architectures (gibt's umsonst)

* gradle Befehle
** local
   #+begin_src
   PROVIDER=local gradle run
   #+end_src

** server
   #+begin_src
   ROLE=SERVER;PORT=2552;SERVER=0.0.0.0:2552 gradle run
   #+end_src
** clients
   #+begin_src
   ROLE=SERVER;PORT=2552;SERVER=0.0.0.0:2552 gradle run
   #+end_src
** UI
   #+begin_src
   ROLE=UI;PORT=2553;SERVER=0.0.0.0:2552 gradle run
   #+end_src
